
//Initialize the display.
void POS_disp_init(void){
    //Check to see if our buffer is busy or if we have already initialized the display.
    if(IFS1bits.U2TXIF == 0 && dispinit == 0){
        Port2_Buffer[0] = 0x0C;     //Clear display.
        Port2_Buffer[1] = 0x12;     //Auto Return Off.
        Port2_Buffer[2] = 0x0E;     //Cursor Off.
        //Dispatch the data in the buffers to the display by creating a TX IRQ on PORT 2.
        CBuff_index = 0;            //Start Index at 0.
        CBuff_max_data = 2;        //End Index at 43 bytes. 44? Arrays start at 0 right?
        IFS1bits.U2TXIF = 1;        //Start transmitting by manually send an IRQ.
        dispinit = 1;
    }
    
}

//Writes data to Display Port Buffer for a 20 x 2 POS display. Model:??????
//This model uses rs232 so you must use a level converter for rs232.
//Dash Board display.
void POS_dash_display(void){
    
    //Check to see if our buffer is busy or if our display is initialized.
    if(IFS1bits.U2TXIF == 0 && dispinit == 1){
        //Top Row.
        //Display Setup.
        CBuff_index = 0;
        Port2_Buffer[CBuff_index] = 0x16;             //Cursor Home
        //Display Voltage.
        CBuff_index = 1;
        float_send(battery_voltage, BigBuffer);  //battery voltage
        CBuff_index = 6;
        send_string(TXT, "V ", BigBuffer);
        //Battery Watts In/Out
        CBuff_index = 8;
        config_space = 1;
        float_send((battery_vltg_average * battery_crnt_average), BigBuffer);      //battery watts
        CBuff_index = 13;
        send_string(TXT, "W ", BigBuffer);
        //Battery  % charge
        CBuff_index = 15;
        float batt_percent = 0;
        batt_percent = ((battery_remaining / battery_capacity) * 100);
        if(batt_percent >= 100){
            send_string(TXT, " ", BigBuffer);
            float_send(batt_percent, BigBuffer);   //battery percentage remaining
            CBuff_index = 20;
            send_string(TXT, "%", BigBuffer);
        }
        else{
            float_send(batt_percent, BigBuffer);   //battery percentage remaining
            CBuff_index = 20;
            send_string(TXT, "%", BigBuffer);
        }

        //Bottom Row Start.
        CBuff_index = 21;
        nl_send(BigBuffer);
        return_send(BigBuffer);
        CBuff_index = 23;
        send_string(TXT, "BT ", BigBuffer);
        CBuff_index = 25;
        config_space = 0;
        float_send(battery_temp, BigBuffer);
        CBuff_index = 30;
        send_string(TXT, "C   ", BigBuffer);
        CBuff_index = 32;
        //Low Battery
        if(batt_percent < 10){
            //Make low battery message blink.
            if(error_blink){
                send_string(TXT, "Low Batt!  ", BigBuffer);
            }
            else{
                send_string(TXT, "           ", BigBuffer);
            }
        }
        else{
            send_string(TXT, "           ", BigBuffer);
        }
        //Error status.
        CBuff_index = 42;
        if(fault_count != 0){
            //Make error message blink.
            if(error_blink){
                send_string(TXT, "E", BigBuffer);
            }
            else{
                send_string(TXT, " ", BigBuffer);
            }
        }
        else{
            send_string(TXT, " ", BigBuffer);
            err_scroll = 0;
        }
        Port2_Buffer[44] = 0x12;     //Auto Return Off.
        Port2_Buffer[45] = 0x0E;     //Cursor Off.
        
        //Diag variable viewer.
        //CBuff_index = 23;
        //float_send(crnt_integral, BigBuffer);
        //Dispatch the data in the buffers to the display by creating a TX IRQ on PORT 2.
        CBuff_index = 0;            //Start Index at 0.
        CBuff_max_data = 45;        //End Index at 43 bytes. 44? Arrays start at 0 right?
        IFS1bits.U2TXIF = 1;        //Start transmitting by manually send an IRQ.
    }
}
//*************************************88
//Diagnostics display.
void POS_diag_display(void){
    
    //Check to see if our buffer is busy or if our display is initialized.
    if(IFS1bits.U2TXIF == 0 && dispinit == 1){
        //Top Row.
        //Display Setup.
        CBuff_index = 0;
        Port2_Buffer[CBuff_index] = 0x16;             //Cursor Home
        //Display Voltage.
        CBuff_index = 1;
        float_send(battery_voltage, BigBuffer);  //battery voltage
        CBuff_index = 6;
        send_string(TXT, "V ", BigBuffer);
        //Battery Watts In/Out
        CBuff_index = 8;
        config_space = 1;
        float_send((battery_vltg_average * battery_crnt_average), BigBuffer);      //battery watts
        CBuff_index = 13;
        send_string(TXT, "W ", BigBuffer);
        //Battery  % charge
        CBuff_index = 15;
        float batt_percent = 0;
        batt_percent = ((battery_remaining / battery_capacity) * 100);
        if(batt_percent >= 100){
            send_string(TXT, " ", BigBuffer);
            float_send(batt_percent, BigBuffer);   //battery percentage remaining
            CBuff_index = 20;
            send_string(TXT, "%", BigBuffer);
        }
        else{
            float_send(batt_percent, BigBuffer);   //battery percentage remaining
            CBuff_index = 20;
            send_string(TXT, "%", BigBuffer);
        }

        //Bottom Row Start.
        CBuff_index = 21;
        nl_send(BigBuffer);
        return_send(BigBuffer);
        CBuff_index = 23;
        //Charging status. 4 char
        if(battery_crnt_average > 0.1){
            send_string(TXT, "Chrg ", BigBuffer);
        }
        else if(battery_crnt_average < -0.1){
            send_string(TXT, "Dis  ", BigBuffer);
        }
        else {
            send_string(TXT, "Idle ", BigBuffer);
        }
        //Heating status. 8 char
        CBuff_index = 28;
        if(heat_power >= 1){
            send_string(TXT, "Htr On  ", BigBuffer);
        }
        else{
            send_string(TXT, "Htr Off ", BigBuffer);
        }
        //Error status. 7 char
        CBuff_index = 36;
        if(fault_count != 0){
            //Make error message blink.
            if(error_blink){
                if(err_scroll >= fault_count - 1){
                    err_scroll = 0;
                }
                else{
                    err_scroll++;
                }
                if(err_scroll == fault_count - 1){
                    send_string(TXT, "END    ", BigBuffer);
                }
                else if(err_scroll == 0){
                    send_string(TXT, "Strt   ", BigBuffer);
                }
                else{
                    send_string(TXT, "       ", BigBuffer);
                }
            }
            else{
                if(err_scroll == fault_count - 1){
                    send_string(TXT, "END    ", BigBuffer);
                }
                else if(err_scroll == 0){
                    send_string(TXT, "Strt   ", BigBuffer);
                }
                else{
                    send_string(TXT, "       ", BigBuffer);
                }
            }
            Port2_Buffer[41] = four_bit_hex_cnvt((fault_codes[err_scroll] & 0xF0) / 16);
            Port2_Buffer[42] = four_bit_hex_cnvt(fault_codes[err_scroll] & 0x0F);
            Port2_Buffer[43] = 'h';
        }
        else{
            send_string(TXT, "Sys OK ", BigBuffer);
            err_scroll = 0;
        }

        //Dispatch the data in the buffers to the display by creating a TX IRQ on PORT 2.
        CBuff_index = 0;            //Start Index at 0.
        CBuff_max_data = 43;        //End Index at 43 bytes. 44? Arrays start at 0 right?
        IFS1bits.U2TXIF = 1;        //Start transmitting by manually send an IRQ.
    }
}




    while (U1STAbits.URXDA && cmdRDY == 0){       //Data ready? Keep reading the whole buffer.
        cmd[cmdPoint] = U1RXREG;
        if (Lecho && ((cmd[cmdPoint] != 0x0D) || (cmd[cmdPoint] != 0x0A))){
            U1TXREG = cmd[cmdPoint];
        }
        if (cmd[cmdPoint] == 0x0D){     //Check for a RETURN
            if (Lecho){
                //U1TXREG = 0x0A;             //Send NewLine
                U1TXREG = 0x0D;             //Send Return
            }
            bufsize = cmdPoint;
            cmdPoint = 0;
            cmdRDY = 1;                 //Tell our command handler to process.
        }
        else if(cmdPoint < cdmd) {
            cmdPoint++;
        }
    }
    //Command Handler.
    if (cmdRDY == 1){
        int tempPoint = 0;
        U1TXREG = '@';                 //Send command receive "@"
        //Check for faults.
        if(fault_count > 0){
            U1TXREG = '!';             //Send fault alert "!"
        }
        switch(cmd[tempPoint]){
            case 0x0D:
            break;
            case '#':
                cmdPoint = 0;
                cmdRDY = 0;
                asm("reset");
            break;
            case 'H':
                heat_cal_stage = 1;
            break;
            case 'E':
                tempPoint++;
                if (cmd[tempPoint] == 'y'){
                    Lecho = 1;
                }
                else if (cmd[tempPoint] == 'n'){
                    Lecho = 0;
                }
                else {
                    Terr = -1;
                }
            break;
            case 'S':
                deep_sleep = 1;
            break;
            case 'r':
                if (read_vars == 0){
                    read_vars = 1;    //Read vars once before stopping.
                }
                else {
                    read_vars = 0;
                }
            break;
            case 'F':
                fault_read(full, PORT1);          //Read all fault codes.
            break;
            case 'P':
                send_string(NLtxtNL, "P On", PORT1);
                cmd_power = 1;
            break;
            case 'p':
                send_string(NLtxtNL, "P Off", PORT1);
                cmd_power = 0;
            break;
            case 'M':
                b_safe = 0;
                send_string(NLtxtNL, "BMon On :D", PORT1);
            break;
            case 'm':
                b_safe = 0x55FF;
                send_string(NLtxtNL, "!BMon Off!", PORT1);
            break;
            case 'C':
                fault_count = 0;
                fault_shutdown = 0;
                heat_cal_stage = 0;
                osc_fail_event = 0;
                send_string(NLtxtNL, "FC Clrd", PORT1);
            break;
            case 'Z':
                p_charge = 0;
                chrg_voltage = battery_rated_voltage;
                if(PORTEbits.RE8 == 1){
                    partial_chrg_cnt = 0;
                }
                else{
                    partial_chrg_cnt = 10;
                }
            break;
            case 'h':
                heat_cal_stage = 5;
            break;
            case 'V':
                send_string(NLtxt, "BV ", PORT1);
                float_send(voltage_percentage, PORT1);
                send_string(txtNL, "%. ", PORT1);
            break;
            case 'B':
                send_string(NLtxt, "RC ", PORT1);
                float_send(amp_hour_rating, PORT1);
                send_string(txtNL, "Ah. ", PORT1);
                send_string(NLtxt, "CalcC ", PORT1);
                float_send(battery_capacity, PORT1);
                send_string(txtNL, "Ah. ", PORT1);
                send_string(NLtxt, "RemainC ", PORT1);
                float_send(battery_remaining, PORT1);
                send_string(txtNL, "Ah. ", PORT1);
            break;
            case 'O':
                use_POS_display = 1;
            break;
            case 'o':
                use_POS_display = 0;
            break;
            case 'U':
                if(v_test < 99){
                    v_test++;
                }
            break;
            case 'u':
                if(v_test > 0){
                    v_test--;
                }
            break;
            default:
                send_string(NLtxt, "Unknown Command.", PORT1);
                Terr = -1;
            break;
        }

        cmdPoint = 0;
        cmdRDY = 0;
        if (Terr == -1){
            Terr = 0;
            cmdPoint = 0;
            tempPoint = 0;
            U1TXREG = 0x45;     //Print "E" for Error.
        }
    }

//Print vars to serial port.
void print_vars(int serial_port){
        send_string(NLtxtNL, "Bt Vltg ", serial_port);
        float_send(battery_voltage, serial_port);
        send_string(TXT, "V", serial_port);
        send_string(NLtxtNL, "Opn Vltg", serial_port);
        float_send(open_voltage, serial_port);
        send_string(TXT, "V", serial_port);
        send_string(NLtxtNL, "Trgt Vltg", serial_port);
        float_send(chrg_voltage, serial_port);
        send_string(TXT, "V", serial_port);
        send_string(NLtxtNL, "Crnt ", serial_port);
        float_send(battery_crnt_average, serial_port);
        send_string(TXT, "A", serial_port);
        send_string(NLtxtNL, "Crnt Use ", serial_port);
        float_send(battery_usage, serial_port);
        send_string(TXT, "AH", serial_port);
        send_string(NLtxtNL, "Pk Out ", serial_port);
        float_send(peak_power, serial_port);
        send_string(TXT, "W  At ", serial_port);
        float_send(peak_pwr_vlts, serial_port);
        send_string(TXT, "V  and ", serial_port);
        float_send(peak_pwr_crnt, serial_port);
        send_string(TXT, "A", serial_port);
        send_string(NLtxtNL, "Batt Temp ", serial_port);
        float_send(battery_temp, serial_port);
        send_string(TXT, "C", serial_port);
        send_string(NLtxtNL, "Ctrl Temp ", serial_port);
        float_send(motor_ctrl_temp, serial_port);
        send_string(TXT, "C", serial_port);
        send_string(NLtxtNL, "My Temp ", serial_port);
        float_send(my_temp, serial_port);
        send_string(TXT, "C", serial_port);
        send_string(NLtxtNL, "Crnt Comp ", serial_port);
        float_send(current_compensate, serial_port);
        send_string(TXT, "A", serial_port);
        send_string(txtNL, " ", serial_port);
}


//Error code stuff, prepares error codes to be sent to PORT2's Display Buffer.
//TODO: Not Finished. What's not finished here? I don't remember.
void smpl_err_send(int serial_port){
    if (serial_port == PORT1){
        U1TXREG = four_bit_hex_cnvt((fault_codes[err_scroll] & 0xF0) / 16);
        U1TXREG = four_bit_hex_cnvt(fault_codes[err_scroll] & 0x0F);
    }
    //Transmit on port 2
    if (serial_port == PORT2){
        U2TXREG = four_bit_hex_cnvt((fault_codes[err_scroll] & 0xF0) / 16);
        U2TXREG = four_bit_hex_cnvt(fault_codes[err_scroll] & 0x0F);
    }
    //Save to Buffer
    if (serial_port == BigBuffer){
        if (CBuff_index < 45){
            CBuff_index++;
        }
        Port2_Buffer[CBuff_index] = four_bit_hex_cnvt((fault_codes[err_scroll] & 0xF0) / 16);
        if (CBuff_index < 45){
            CBuff_index++;
        }
        Port2_Buffer[CBuff_index] = four_bit_hex_cnvt(fault_codes[err_scroll] & 0x0F);
    }
    if (serial_port == 0x00){
        fault_log(0x1A);        //Log invalid port error.
    }
}